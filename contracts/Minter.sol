// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "./interfaces/IManagement.sol";
import "./interfaces/IMintable.sol";

contract Minter {

    bytes32 public constant VERSION = keccak256("MINTER_v1");
    bytes32 private constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
    bytes32 private constant AUTHORIZER_ROLE = keccak256("AUTHORIZER_ROLE");
    uint256 private constant SINGLE_UNIT = 1;
    uint256 private constant ERC721 = 721;
    uint256 private constant ERC1155 = 1155;

    address public pubCollection721;
    address public pubCollection1155;

    IManagement public management;

    modifier onlyManager() {
        require(
            management.hasRole(MANAGER_ROLE, msg.sender), "Only Manager"
        );
        _;
    }

    event Mint(
        address indexed collectionAddr,
        uint256 indexed nftType,
        address indexed to,
        uint256 tokenId,
        uint256 amount
    );

    event MintBatch(
        address indexed collectionAddr,
        uint256 indexed nftType,
        address indexed to,
        uint256[] tokenIds
    );

    constructor(IManagement _management, address _pub721, address _pub1155) {
        management = _management;
        pubCollection721 = _pub721;
        pubCollection1155 = _pub1155;
    }

    /**
        @notice Update new Address of Management contract
        @dev    Caller must have MANAGER_ROLE

        @param _newManagement          Address of new Management contract
    */
    function updateManagement(address _newManagement) external onlyManager {
        require(_newManagement != address(0), "Set zero address");

        management = IManagement(_newManagement);
    }

    /**
        @notice Mint NFT Token (ERC721) to `msg.sender`
        @dev    Caller can be ANY

        @param _tokenId          Token ID 
        @param _uri              Token URI
        @param _signature        A signature generated by AUTHORIZER_ROLE
    */
    function mint(
        uint256 _tokenId,
        uint256 _expiry,
        string calldata _uri,
        bytes calldata _signature
    ) external {
        require(block.number <= _expiry, "Authorized signature expired");

        address _buyer = msg.sender;
        bytes32 _msgHash = ECDSA.toEthSignedMessageHash(
            keccak256(
                abi.encodePacked(_tokenId, bytes(_uri), _buyer, _expiry)
            )
        );
        _checkAuthorizer(_msgHash, _signature);

        IMintable(pubCollection721).mint(_buyer, _tokenId, _uri);

        emit Mint(pubCollection721, ERC721, _buyer, _tokenId, SINGLE_UNIT);
    }

    /**
        @notice Mint batch of NFT Token (ERC721) to `msg.sender`
        @dev    Caller can be ANY

        @param _tokenIds          Array of Token IDs 
        @param _uris              Array of Token URIs
        @param _signature         A signature generated by AUTHORIZER_ROLE
    */
    function mintBatch(
        uint256 _expiry,
        uint256[] calldata _tokenIds,
        string[] calldata _uris,
        bytes calldata _signature
    ) external {
        uint256 _len = _tokenIds.length;
        require(block.number <= _expiry, "Authorized signature expired");
        require(_uris.length == _len, "Length mismatch");

        bytes memory _packed;
        for (uint256 i; i < _len; i++)
            _packed = abi.encodePacked(_packed, bytes(_uris[i]));

        address _buyer = msg.sender;
        bytes32 _msgHash = ECDSA.toEthSignedMessageHash(
            keccak256(
                abi.encodePacked(_tokenIds, _packed, _buyer, _expiry)
            )
        );
        _checkAuthorizer(_msgHash, _signature);

        IMintable(pubCollection721).mintBatch(_buyer, _tokenIds, _uris);

        emit MintBatch(pubCollection721, ERC721, _buyer, _tokenIds);
    }

    /**
        @notice Mint NFT Token (ERC1155) to `msg.sender`
        @dev    Caller can be ANY

        @param _tokenId          Token Id 
        @param _amount           An amount of Tokens being minted
        @param _uri              Token URI
        @param _signature        A signature generated by AUTHORIZER_ROLE
    */
    function mint(
        uint256 _tokenId,
        uint256 _amount,
        uint256 _expiry,
        string calldata _uri,
        bytes calldata _signature
    ) external {
        require(block.number <= _expiry, "Authorized signature expired");

        address _buyer = msg.sender;
        bytes32 _msgHash = ECDSA.toEthSignedMessageHash(
            keccak256(
                abi.encodePacked(_tokenId, _amount, bytes(_uri), _buyer, _expiry)
            )
        );
        _checkAuthorizer(_msgHash, _signature);

        IMintable(pubCollection1155).mint(_buyer, _tokenId, _amount, _uri);

        emit Mint(pubCollection1155, ERC1155, _buyer, _tokenId, _amount);
    }

    /**
        @notice Mint batch of NFT Token (ERC1155) to `msg.sender`
        @dev    Caller can be ANY
        
        @param _tokenIds          A list of tokenIds
        @param _amounts           A list of minting amounts
        @param _uris              A list of tokenURIs
        @param _signature         A signature generated by AUTHORIZER_ROLE
    */
    function mintBatch(
        uint256 _expiry,
        uint256[] memory _tokenIds,
        uint256[] memory _amounts,
        string[] memory _uris,
        bytes calldata _signature
    ) external {
        uint256 _len = _tokenIds.length;
        require(block.number <= _expiry, "Authorized signature expired");
        require(
            _amounts.length == _len && _uris.length == _len, "Length mismatch"
        );

        bytes memory _packed;
        for (uint256 i; i < _len; i++)
            _packed = abi.encodePacked(_packed, bytes(_uris[i]));
        
        address _buyer = msg.sender;
        bytes32 _msgHash = ECDSA.toEthSignedMessageHash(
            keccak256(
                abi.encodePacked(_tokenIds, _amounts, _packed, _buyer, _expiry)
            )
        );
        _checkAuthorizer(_msgHash, _signature);

        IMintable(pubCollection1155).mintBatch(_buyer, _tokenIds, _amounts, _uris);

        emit MintBatch(pubCollection1155, ERC1155, _buyer, _tokenIds);
    }

    function _checkAuthorizer(bytes32 _msgHash, bytes calldata _signature) private view {
        require(
            management.hasRole(AUTHORIZER_ROLE, ECDSA.recover(_msgHash, _signature)), "Invalid signature"
        );
    }
}
