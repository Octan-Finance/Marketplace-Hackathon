// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract Collection is Ownable, ERC721URIStorage {

    struct SubCollection {
        uint256 maxEdition;
        uint256 mintedAmt;
    }

    bytes32 public constant VERSION = keccak256("COLLECTION_v1");
    uint256 private constant SINGLE_UNIT = 1;

    uint256 public collectionId;
    uint256 public subcollectionId;

    mapping(uint256 => SubCollection) public subcollections;

    event NewCollection(
        address indexed collectionAddr,
        uint256 indexed collectionId,
        uint256 indexed subCollectionId,
        uint256 maxEdition
    );

    event CollectionMint(
        address indexed collectionAddr,
        address indexed to,
        uint256 indexed tokenId
    );

    event CollectionMintBatch(
        address indexed collectionAddr,
        address indexed to,
        uint256[] tokenIds
    );

    constructor(
        uint256 _collectionId,
        uint256 _maxEdition,
        string memory _name,
        string memory _symbol
    ) ERC721(_name, _symbol) Ownable() {
        collectionId = _collectionId;
        
        _addSubCollection(_maxEdition);
    }

    /**
        @notice Add sub-collection
        @dev Caller must be Owner
        
        @param _maxEdition             Maximum number of items in the sub-collection
    */
    function addSubCollection(uint256 _maxEdition) external onlyOwner {
        require(_maxEdition != 0, "Max Edition must be non-zero");

        _addSubCollection(_maxEdition);
    }

    /**
       @notice Mint item to `_to`
       @dev Caller must be Owner

       @param _to                   Receiver Address
       @param _tokenId              Token ID
       @param _uri                  Token URI
    */
    function mint(address _to, uint256 _tokenId, string calldata _uri) external onlyOwner {
        _precheck(_tokenId, SINGLE_UNIT);
       
        _safeMint(_to, _tokenId, "");
        _setTokenURI(_tokenId, _uri);

        emit CollectionMint(address(this), _to, _tokenId);
    }

    /**
        @notice Mint Batch of NFT items to a receiver `to`
        @dev Caller must be Owner

        @param _to                    Receiver Address
        @param _tokenIds              Array of Token IDs
        @param _uris                  Array of Token URIs

        Note: A batch of `tokenID` must be in one sub-collection only
    */
    function mintBatch(
        address _to,
        uint256[] calldata _tokenIds,
        string[] calldata _uris
    ) external onlyOwner {
        uint256 _amount = _tokenIds.length;
        require(_amount == _uris.length, "Length mismatch");

        _checkBatchRequirement(_tokenIds);
        _precheck(_tokenIds[0], _amount);

        for (uint256 i; i < _amount; i++) {
            _safeMint(_to, _tokenIds[i], "");
            _setTokenURI(_tokenIds[i], _uris[i]);
        }

        emit CollectionMintBatch(address(this), _to, _tokenIds);
    }

    /**
        @notice Lazy Minting an item to `_to`
        @dev Caller can be ANY

        @param _to                  Receiver Address
        @param _tokenId             Token ID number
        @param _uri                 Token URI
        @param _signature           A signature generated by Owner to authorize lazy minting
    */
    function lazymint(
        address _to,
        uint256 _tokenId,
        string calldata _uri,
        bytes calldata _signature
    ) external {
        _precheck(_tokenId, SINGLE_UNIT);
        bytes32 _msgHash = ECDSA.toEthSignedMessageHash(
            keccak256(
                abi.encodePacked(address(this), collectionId, _tokenId, _to, bytes(_uri))
            )
        );
        require(
            ECDSA.recover(_msgHash, _signature) == owner(), "Invalid signature"
        );

        _safeMint(_to, _tokenId, "");
        _setTokenURI(_tokenId, _uri);

        emit CollectionMint(address(this), _to, _tokenId);
    }

    function _precheck(uint256 _tokenId, uint256 _amount) private {
        //  TokenId is created following this rule:
        //  Collection ID + Sub-collection ID (4 digits) + Edition Number (6 digits)
        //  For example: TokenId = 230004000088
        //  Collection ID = 23, Sub-collection ID = 4, Edition Number = 88
        uint256 _collectionId = _tokenId / 10**10;
        require(_collectionId == collectionId, "Invalid collection");

        uint256 _subcollectionId = (_tokenId % 10**10) / 10**6;
        uint256 _mintedAmt = subcollections[_subcollectionId].mintedAmt + _amount;
        require(
            subcollections[_subcollectionId].maxEdition >= _mintedAmt, "Exceed max edition"
        );

        subcollections[_subcollectionId].mintedAmt = _mintedAmt;
    }

    function _checkBatchRequirement(uint256[] calldata _ids) private pure {
        uint256 _len = _ids.length;
        uint256 slice1 = _ids[0] / 10**6;
        uint256 slice2;

        for (uint256 i = 1; i < _len; i++) {
            slice2 = _ids[i] / 10**6;
            require(slice1 == slice2, "Invalid TokenIds");
        }
    }

    function _addSubCollection(uint256 _maxEdition) private {
        subcollectionId++;
        subcollections[subcollectionId].maxEdition = _maxEdition;

        emit NewCollection(address(this), collectionId, subcollectionId, _maxEdition);
    }
}

